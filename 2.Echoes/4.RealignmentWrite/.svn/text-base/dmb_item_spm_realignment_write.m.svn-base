function dmb_menu_spm_realignment_write = dmb_menu_spm_realignment_write

% SPM Configuration file
% automatically generated by the MATLABBATCH utility function GENCODE
%_______________________________________________________________________
% Copyright (C) 2008 Wellcome Trust Centre for Neuroimaging

% $Id: spm_cfg_realign.m 4152 2011-01-11 14:13:35Z volkmar $

% ---------------------------------------------------------------------
% data Images
% ---------------------------------------------------------------------
data         = cfg_files;
data.tag     = 'data';
data.name    = 'Images';
data.help    = {'Select scans to reslice to match the first.'};
data.filter = 'image';
data.ufilter = '.*';
data.num     = [1 Inf];
% ---------------------------------------------------------------------
% which Resliced images
% ---------------------------------------------------------------------
which         = cfg_menu;
which.tag     = 'which';
which.name    = 'Resliced images';
which.help    = {
                 'All Images (1..n) :   This reslices all the images - including the first image selected   - which will remain in its original position.'
                 ''
                 'Images 2..n :    Reslices images 2..n only. Useful for if you wish to reslice    (for example) a PET image to fit a structural MRI, without    creating a second identical MRI volume.'
                 ''
                 'All Images + Mean Image :    In addition to reslicing the images, it also creates a mean of the    resliced image.'
                 ''
                 'Mean Image Only :    Creates the mean resliced image only.'
}';
which.labels = {
                ' All Images (1..n)'
                'Images 2..n'
                ' All Images + Mean Image'
                ' Mean Image Only'
}';
which.values = {[2 0] [1 0] [2 1] [0 1]};
which.def    = @(val)spm_get_defaults('realign.write.which', val{:});
% ---------------------------------------------------------------------
% interp Interpolation
% ---------------------------------------------------------------------
interp         = cfg_menu;
interp.tag     = 'interp';
interp.name    = 'Interpolation';
interp.help    = {'The method by which the images are sampled when being written in a different space. Nearest Neighbour is fastest, but not recommended for image realignment. Bilinear Interpolation is probably OK for PET, but not so suitable for fMRI because higher degree interpolation generally gives better results/* \cite{thevenaz00a,unser93a,unser93b}*/. Although higher degree methods provide better interpolation, but they are slower because they use more neighbouring voxels. Fourier Interpolation/* \cite{eddy96,cox99}*/ is another option, but note that it is only implemented for purely rigid body transformations.  Voxel sizes must all be identical and isotropic.'};
interp.labels = {
                 'Nearest neighbour'
                 'Trilinear'
                 '2nd Degree B-Spline'
                 '3rd Degree B-Spline'
                 '4th Degree B-Spline'
                 '5th Degree B-Spline'
                 '6th Degree B-Spline'
                 '7th Degree B-Spline'
                 'Fourier Interpolation'
}';
interp.values = {0 1 2 3 4 5 6 7 Inf};
interp.def    = @(val)spm_get_defaults('realign.write.interp', val{:});
% ---------------------------------------------------------------------
% wrap Wrapping
% ---------------------------------------------------------------------
wrap         = cfg_menu;
wrap.tag     = 'wrap';
wrap.name    = 'Wrapping';
wrap.help    = {
                'This indicates which directions in the volumes the values should wrap around in.  For example, in MRI scans, the images wrap around in the phase encode direction, so (e.g.) the subject''s nose may poke into the back of the subject''s head. These are typically:'
                '    No wrapping - for PET or images that have already                   been spatially transformed.'
                '    Wrap in  Y  - for (un-resliced) MRI where phase encoding                   is in the Y direction (voxel space).'
}';
wrap.labels = {
               'No wrap'
               'Wrap X'
               'Wrap Y'
               'Wrap X & Y'
               'Wrap Z'
               'Wrap X & Z'
               'Wrap Y & Z'
               'Wrap X, Y & Z'
}';
wrap.values = {[0 0 0] [1 0 0] [0 1 0] [1 1 0] [0 0 1] [1 0 1] [0 1 1]...
               [1 1 1]};
wrap.def    = @(val)spm_get_defaults('realign.write.wrap', val{:});
% ---------------------------------------------------------------------
% mask Masking
% ---------------------------------------------------------------------
mask         = cfg_menu;
mask.tag     = 'mask';
mask.name    = 'Masking';
mask.help    = {'Because of subject motion, different images are likely to have different patterns of zeros from where it was not possible to sample data. With masking enabled, the program searches through the whole time series looking for voxels which need to be sampled from outside the original images. Where this occurs, that voxel is set to zero for the whole set of images (unless the image format can represent NaN, in which case NaNs are used where possible).'};
mask.labels = {
               'Mask images'
               'Dont mask images'
}';
mask.values = {1 0};
mask.def    = @(val)spm_get_defaults('realign.write.mask', val{:});
% ---------------------------------------------------------------------
% prefix Filename Prefix
% ---------------------------------------------------------------------
prefix         = cfg_entry;
prefix.tag     = 'prefix';
prefix.name    = 'Filename Prefix';
prefix.help    = {'Specify the string to be prepended to the filenames of the resliced image file(s). Default prefix is ''r''.'};
prefix.strtype = 's';
prefix.num     = [1 Inf];
prefix.def     = @(val)spm_get_defaults('realign.write.prefix', val{:});
% ---------------------------------------------------------------------
% roptions Reslice Options
% ---------------------------------------------------------------------
roptions         = cfg_branch;
roptions.tag     = 'roptions';
roptions.name    = 'Reslice Options';
roptions.val     = {which interp wrap mask prefix };
roptions.help    = {'Various reslicing options. If in doubt, simply keep the default values.'};
% ---------------------------------------------------------------------
% write Realign: Reslice
% ---------------------------------------------------------------------
dmb_menu_spm_realignment_write         = cfg_exbranch;
dmb_menu_spm_realignment_write.tag     = 'write';
dmb_menu_spm_realignment_write.name    = 'Realign: Reslice';
dmb_menu_spm_realignment_write.val     = {data roptions };
dmb_menu_spm_realignment_write.help    = {'This function reslices a series of registered images such that they match the first image selected voxel-for-voxel. The resliced images are named the same as the originals, except that they are prefixed by ''r''.'};
dmb_menu_spm_realignment_write.prog = @spm_run_realign_reslice;
dmb_menu_spm_realignment_write.vout = @vout_reslice;

function dep = vout_reslice(job)
if job.roptions.which(1) > 0
    dep(1)            = cfg_dep;
    dep(1).sname      = 'Resliced Images';
    dep(1).src_output = substruct('.','rfiles');
    dep(1).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;
if ~strcmp(job.roptions.which,'<UNDEFINED>') && job.roptions.which(2),
    if exist('dep','var')
        dep(end+1) = cfg_dep;
    else
        dep = cfg_dep;
    end;
    dep(end).sname      = 'Mean Image';
    dep(end).src_output = substruct('.','rmean');
    dep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;
